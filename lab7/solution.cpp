#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

/*

Функция решения задачи. Основная идея в том, что так как нам нужно разместить
каждый шарик в мешок, причем только один, а также так как каждый шарик между двумя, идущими в один мешок,
тоже должны пойти в тот же мешок, по факту разбиение на мешки задается парами индексов шариков, причем
сами индексы идут последовательными парами: конец предыдущего мешка и начало следующего (кроме первого и последнего
мешочков: они автоматически включены в первый и последний мешочек соответственно; именно поэтому мы не берем
их в расчет при вычислении весов мешочков, так как нам все равно надо вернуть их разность). Так как вес
мешочка высчитывается как сумма его границ (веса шариков, заданных граничными индексами), для вычисления
текущего разбиения необходимо только k - 1 сумм пар весов граничных шариков. Тогда строим массив сумм пар
весов граничных шариков и выбираем из них k - 1 максимальных и столько же минимальных сумм, чтобы получить 
максимальное и минимальное разбиения, после чего возвращаем разность.

сложность - O(n + n*log(n) + k) ~ O(n*log(n)), расход по памяти (в коде указан в байтах) = 8n + 12 байт
*/
long long putMarbles(vector<int>& weights, int k) {
    int n = weights.size(); // +4
    vector<long long> pairs(n - 1); // +8n - 8,
                                    // сам массив сумм пар граничных шариков

    for (int i = 0; i < n - 1; i++) pairs[i] = weights[i] + weights[i + 1]; // O(n), высчитываем суммы пар

    sort(pairs.begin(), pairs.end()); // O(n*log(n)), чтобы быстро получить k - 1 максимальных
                                      // и k - 1 минимальных элементов отсортируем массив

    long long max_part = 0, min_part = 0; // +16, максимальное и минимальное разбиение

    for (int i = 0; i < k - 1; i++){ // O(k), считаем их
        min_part += pairs[i];
        max_part += pairs[n - 2 - i];
    }

    return max_part - min_part;
}

int main(){
    vector<int> test = {1, 3, 5, 1};
    cout << putMarbles(test, 2);
}