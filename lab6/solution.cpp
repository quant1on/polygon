#include <iostream>
#include <string>
#include <vector>
#include <stack>
using namespace std;

//функция подсчета маскимального прямоугольника (прямоугольника максимальной площади)
//по факту, основной смысл состоит в том, чтобы подсчитать левые и правые границы для каждого
//столбца гистограммы, как будто мы пытались бы "расширить" его максимально влево и вправо

//асимптотика - O(m), где m - кол-во столбцов в изначальной матрице, расход = 8 * m + 12
int RectangleArea(int height[], int m){
    pair<int, int> limits[m]; //массив границ для конкретного стобца гистограммы, 4 * m
    stack<int> dp;            //стек для определения границ, в худшем случае может хранить в себе
                              //все индексы гистограммы height[], тогда расход будет 4 * m
                              
    int i = 0, max_area = 0;  //индекс для итерирования по гистограмме, ответ, 4 + 4 = 8

    //проходимся слева направо по гистограмме, чтобы найти правые границы. По факту,
    //мы сохраняем условие, что элементы в стеке идут по возрастанию (имеются в виду элементы,
    //соответствующие индексам, хранящимся в стеке), когда же мы встречаем элемент, который ниже элемента, 
    //соответствующего верху стека, мы начинаем "сбивать" со стека все индексы, элементы которых больше, чем
    //новый элемент: по факту, то, что произошло "сбивание индекса из стека", означает, что нашлась правая граница
    //для сбитого элемента

    //добавляем каждый и удаляем каждый элемент по 1 разу, сложность O(m)
    while (i < m){
        if (dp.empty() || height[dp.top()] <= height[i]){
            dp.push(i);
            i++;
        }
        else{
            limits[dp.top()].second = i - 1;
            dp.pop();
        }
    }
    //если после рассмотрения всех элементов в стеке остались индексы, значит, не нашлось 
    //элементов, "сбивающих" или "ограничивающих справа" -> значит, можем поставить максимальную справа,
    //в худшем случае O(m)
    while (!dp.empty()){
        limits[dp.top()].second = m - 1;
        dp.pop();
    }

    i--;

    //полностью аналогично, только проходим не слева направо, с справа налево и ищем левые границы.
    //в худшем случае O(m)
    while (i >= 0){
        if (dp.empty() || height[dp.top()] <= height[i]){
            dp.push(i);
            i--;
        }
        else{
            limits[dp.top()].first = i + 1;
            dp.pop();
        }
    }

    //все так же, если остались в стеке после рассмотрения всей гистограммы -> ставим для
    //всех оставшихся минимальную левую границу; в худшем случае O(m)
    while (!dp.empty()){
        limits[dp.top()].first = 0;
        dp.pop();
    }

    //теперь зная левую и правую границу каждого элемента гистограммы посчитаем площадь прямоугольников,
    //полученных при расширении каждого элемента гистограммы
    //O(m)
    int area; //переменная для удобного дебаггинга, 4
    for (int j = 0; j < m; j++){
        area = height[j] * (limits[j].second - limits[j].first + 1);
        max_area = max(max_area, area);
    }

    return max_area;
}


//собственно, сама функция нахождения максимальной площади из '1' в бинарной матрице. Основная идея - 
//рассматривая матрицу построчно, построим массив непрерывных единичных столбцов для каждого "слоя". Это
//можно сделать следующим образом: если для рассматриваемого слоя в i-ом столбце стоит '1', то при обновлении
//массива столбцов на этом месте увеличим столбец на 1, если встретился '0' -> столбец "оборвался", значит,
//обнуляем для этой позиции столбец в массиве. По факту, мы строим гистограмму для каждой строки изначальной матрицы.
//Далее для каждого слоя находим максимальную возможную площадь, после чего находим максимальную возможную площадь
//среди всех слоев.

//O(n * m), расход = 12 * m + 20 байт, где n - кол-во строк, m - кол-во стобцов
int maximalRectangle(vector<vector<char>>& matrix){
    int clmns = matrix[0].size(), //кол-во столбцов, 4
    rows = matrix.size(), ans = 0; //кол-во строк и ответ, 4 + 4 = 8

    int height[clmns]; //сама гистограмма, 4 * m, где m - вол-во столбцов
    for (int i = 0; i < clmns; i++) height[i] = 0; //обнуляем все элементы гистограммы,
                                                   //так как изначально все столбцы высоты 0
    
    //находим максимальную площадь для каждого слоя, находим максимальную среди них
    //сложность O(n), общая сложность O(n * m), где n - кол-во строк, m - кол-во столбцов
    for (int i = 0; i < rows; i++){
        //O(m) 
        for (int j = 0; j < clmns; j++){
            if (matrix[i][j] == '0') height[j] = 0; //по принципу, описанному выше
            else height[j]++;
        }

        ans = max(ans, RectangleArea(height, clmns)); //считаем максимальную площадь для каждого слоя,
                                                      //O(m), расход = 8 * m + 12
    }

    return ans;
}


int main(){
    vector<vector<char>> test;
    test = {
        {'1', '0', '1', '0', '0'},
        {'1', '0', '1', '1', '1'},
        {'1', '1', '1', '1', '1'},
        {'1', '0', '0', '1', '0'}
    };

    cout << maximalRectangle(test);
}